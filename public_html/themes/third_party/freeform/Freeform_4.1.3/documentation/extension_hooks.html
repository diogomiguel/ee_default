<!DOCTYPE html>
<!--[if lt IE 7]>		<html class="no-js ie6"> <![endif]-->
<!--[if IE 7]>			<html class="no-js ie7"> <![endif]-->
<!--[if IE 8]>			<html class="no-js ie8"> <![endif]-->
<!--[if IE 8]>			<html class="no-js ie9"> <![endif]-->
<!--[if gt IE 9]><!-->	<html class="no-js"> <!--<![endif]-->
	<head lang="en">
		<meta charset="utf-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
		<title>Extension Hooks | Freeform | Solspace Addon Documentation</title>
		<meta name="description" content="" />
		<meta name="copyright" content="(c) 2010 Copyright content: Copyright design: Solspace, Inc."/>
		<meta name="viewport" content="width=device-width" />
		<link rel="stylesheet" href="assets/css/normalize.css" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<link rel="stylesheet" type="text/css" href="assets/fancybox/jquery.fancybox-1.3.4.css" />
		<link href="assets/syntaxhighlighter/styles/shCore.css" rel="stylesheet" type="text/css" />
		<link href="assets/syntaxhighlighter/styles/shThemeDefault.css" rel="stylesheet" type="text/css" />
		<script src="assets/js/modernizr.min.js"></script>
	</head>
	<body>
		<!--[if lt IE 8]>
			<p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
		<![endif]-->

		<header>
			<div class="header-inner">
				<div class="logo">
					<img src="assets/images/logo.png" />
				</div>

				<div class="bread_crumbs">
					<ul class="crumbs">
						<li class="first"><a href="index.html">Freeform</a></li>
						<li>Extension Hooks</li>
					</ul>
				</div>
			</div>
		</header>

		<div class="content-wrapper">
			<nav class="toc">
				<ul>
<li><a href="http://www.solspace.com/software/detail/freeform/">More Info | Purchase</a></li>
<li><a href="change_log.html">Change Log</a></li>
<li><a href="install_update.html">Install / Update</a></li>
<li><a href="control_panel.html">Control Panel</a></li>
<li><a href="channel_entry_fieldtype.html">Channel Entry Fieldtype</a></li>
<li><a href="default_fieldtypes.html">Default Fieldtypes</a></li>
<li><a href="fieldtype_development.html">Fieldtype Development</a></li>
<li class="current"><a href="extension_hooks.html">Extension Hooks</a></li>
<li><a href="troubleshooting.html">Troubleshooting Guide</a></li>
<li><p><a href="upgrade_3.x-4.x.html">Freeform 3.x to 4.x Guide</a></p></li>
<li class="template_tags"><h3>Template Tags</h3>

<ul>
<li><a href="composer.html">Composer</a></li>
<li><a href="composer_edit.html">Composer_Edit</a></li>
<li><a href="edit.html">Edit</a></li>
<li><a href="entries.html">Entries</a></li>
<li><a href="error_page.html">Error Page</a></li>
<li><a href="form.html">Form</a></li>
<li><a href="form_info.html">Form_Info</a></li>
</ul></li>
<li><h3>Requirements</h3><div class="requirements">

<ul>
<li>ExpressionEngine 2.4+</li>
<li>PHP 5.2+</li>
<li>MySQL 5+</li>
<li>All modern browsers or IE 8+</li>
</ul></div></li>
</ul>
			</nav>

			<article class="docs">
				<h3>File: ./mod.freeform.php and ./mcp.freeform.php</h3>

<ul>
<li><a href="#freeform_module_validate_begin">Entry Validate Begin: freeform_module_validate_begin</a></li>
<li><a href="#freeform_module_validate_end">Entry Validate End: freeform_module_validate_end</a></li>
<li><a href="#freeform_module_insert_begin">Entry Insert Begin: freeform_module_insert_begin</a></li>
<li><a href="#freeform_module_insert_end">Entry Insert End: freeform_module_insert_end</a></li>
</ul>

<h3>File: ./mod.freeform.php</h3>

<ul>
<li><a href="#freeform_module_form_begin">Form Begin: freeform_module_form_begin</a></li>
<li><a href="#freeform_module_pre_form_parse">Form Pre Form Parse: freeform_module_pre_form_parse</a></li>
<li><a href="#freeform_module_form_end">Form End: freeform_module_form_end</a></li>
</ul>

<h3>File: ./libraries/Freeform_Forms.php</h3>

<ul>
<li><a href="#freeform_module_entry_delete">Entry Delete: freeform_module_entry_delete</a></li>
</ul>

<h3>File: ./libraries/Freeform_notifications.php</h3>

<ul>
<li><a href="#freeform_recipient_email">Notification Recipient Email: freeform_recipient_email</a></li>
<li><a href="#freeform_module_admin_notification">Notification Admin Notification: freeform_module_admin_notification</a></li>
<li><a href="#freeform_module_user_notification">Notification User Notification: freeform_module_user_notification</a></li>
</ul>

<p><a name="freeform_module_validate_begin"></a></p>

<h2>freeform_module_validate_begin</h2>

<p>The freeform_module_validate_begin hook currently exists in both the control panel file and module file, due to create/edit entry abilities in the control panel.</p>

<ul>
<li><strong>Files</strong>:

<ul>
<li>mod.freeform.php</li>
<li>mcp.freeform.php</li>
</ul></li>
<li><strong>Method</strong>:

<ul>
<li>mod.freeform.php -&#62; save_form()</li>
<li>mcp.freeform.php -&#62; save_entry()</li>
</ul></li>
<li><strong>Possible Uses</strong>:

<ul>
<li>Allows developers to alter the $error array and add errors before any others are added.</li>
</ul></li>
<li><strong>Variables</strong>:

<ul>
<li>$errors:          (array)     - empty starting error array</li>
<li>$this:            (object)    - class object of function caller</li>
</ul></li>
<li><strong>Important Class Vars</strong>

<ul>
<li>$this->field_errors:  (array) - array of errors for specific fields</li>
<li>$this->edit:          (bool)  - form is in edit mode</li>
<li>$this->multipage:     (bool)  - form is in multipage mode</li>
<li>$this->last_page:     (bool)  - form is posting the last multipage page</li>
</ul></li>
<li><strong>Return</strong>:

<ul>
<li>type: associative array</li>
<li><strong>required: yes</strong></li>
</ul></li>
</ul>

<h4>Important note about multipage forms and form editing:</h4>

<p>With Freeform Pro, it is possible to have multipage forms and edit forms on the front end.</p>

<p>Hooks fire on every page of the a multipage form as data is stored each time, so if you are wanting to run a hook that only does work on the last page, make sure you are checking for <strong>$obj->multipage == TRUE</strong> and <strong>$obj->last_page == TRUE</strong>.</p>

<p>The same goes for editing. If you do not want your extension to do work on edits, check <strong>$obj->edit == TRUE;</strong> before running your code.</p>

<p>Remember to return required return arrays (and check for <strong>extensions->last_call</strong>) either way!</p>

<h4>Important differences from Freeform 3:</h4>

<p>Most errors are now keyed in the error array in order to assist inline errors or json responses to ajax validation, therefore, if you add an error for a specific field, make sure you key the error and add it to <strong>$obj->field_errors</strong> or <strong>$errors</strong> depending on if its a field error or a general error:</p>

<pre class="brush: php;">public function freeform_module_validate_begin($errors, $obj)
{
    $obj-&gt;field_errors['my_field_name'] = lang('error_line');
    $errors['my_general_error']             = lang('error_line_2');
}
</pre>

<p>Also notice that fields are now in their own array in the object container. This is necessary for Freeform's new abilities for inline errors and better ajax validation.</p>

<h4>Hook Code:</h4>

<pre class="brush: php;">if (ee()-&gt;extensions-&gt;active_hook('freeform_module_validate_begin') === TRUE)
{
    $errors = ee()-&gt;extensions-&gt;universal_call(
        'freeform_module_validate_begin',
        $errors,
        $this
    );

    if (ee()-&gt;extensions-&gt;end_script === TRUE) return;
}
</pre>

<h4>Extension function example:</h4>

<pre class="brush: php;">public function freeform_module_validate_begin($errors, $obj)
{
    //have other extensions already manipulated?
    if (ee()-&gt;extensions-&gt;last_call !== FALSE)
    {
        $errors = ee()-&gt;extensions-&gt;last_call;
    }

    //detect and add custom errors
    $obj-&gt;field_errors['my_field_name'] = lang('error_line');
    $errors['my_general_error']             = lang('error_line_2');

    //must return error array
    return $errors;
}
</pre>

<h4>Detecting Class object:</h4>

<p>Since the hook is called from two different classes, you might need to detect which one for your extension's purposes. This can be achieved two ways:</p>

<p><strong>REQ Detection:</strong></p>

<pre class="brush: php;">if (REQ == 'CP')
{
    //request is from control panel
}
else
{
    //request is from template
}
</pre>

<p><strong>Class Detection:</strong></p>

<pre class="brush: php;">public function freeform_module_validate_begin($errors, $obj)
{
    if (get_class($obj) == 'Freeform')
    {
        //request is from template
    }
    else
    {
        //request is from control panel
    }
}
</pre>

<p><a name="freeform_module_validate_end"></a></p>

<h2>freeform_module_validate_end</h2>

<p>The freeform_module_validate_end hook currently exists in both the control panel file and module file, due to create/edit entry abilities in the control panel.</p>

<ul>
<li><strong>Files</strong>:

<ul>
<li>mod.freeform.php</li>
<li>mcp.freeform.php</li>
</ul></li>
<li><strong>Method</strong>:

<ul>
<li>mod.freeform.php -&#62; save_form()</li>
<li>mcp.freeform.php -&#62; save_entry()</li>
</ul></li>
<li><strong>Possible Uses</strong>:

<ul>
<li>Allows developers to alter the $error array and edit errors before the errors are sent to the user.</li>
</ul></li>
<li><strong>Variables</strong>:

<ul>
<li>$errors:  (array)     - all errors after validation has finished</li>
<li>$this:    (object)    - class object of function caller</li>
</ul></li>
<li><strong>Important Class Vars</strong>

<ul>
<li>$this->field_errors:  (array) - array of errors for specific fields</li>
<li>$this->edit:          (bool)  - form is in edit mode</li>
<li>$this->multipage:     (bool)  - form is in multipage mode</li>
<li>$this->last_page:     (bool)  - form is posting the last multipage page</li>
</ul></li>
<li><strong>Return</strong>:

<ul>
<li>type: associative array</li>
<li><strong>required: yes</strong></li>
</ul></li>
</ul>

<p>Unlike freeform_module_validate_begin, this hook occurs right before errors are sent to the user and already has all errors added by Freeform or the freeform_module_validate_begin hook included in the <strong>$errors</strong> var and <strong>$obj->field_errors</strong> array.</p>

<h4>Important note about multipage forms and form editing:</h4>

<p>With Freeform Pro, it is possible to have multipage forms and edit forms on the front end.</p>

<p>Hooks fire on every page of the a multipage form as data is stored each time, so if you are wanting to run a hook that only does work on the last page, make sure you are checking for <strong>$obj->multipage == TRUE</strong> and <strong>$obj->last_page == TRUE</strong>.</p>

<p>The same goes for editing. If you do not want your extension to do work on edits, check <strong>$obj->edit == TRUE;</strong> before running your code.</p>

<p>Remember to return required return arrays (and check for <strong>extensions->last_call</strong>) either way!</p>

<h4>Important differences from Freeform 3:</h4>

<p>Most errors are now keyed in the error array in order to assist inline errors or json responses to ajax validation, therefore, if you add an error for a specific field, make sure you key the error and add it to <strong>$obj->field_errors</strong> or <strong>$errors</strong> depending on if its a field error or a general error:</p>

<pre class="brush: php;">public function freeform_module_validate_end($errors, $obj)
{
    $obj-&gt;field_errors['my_field_name'] = lang('error_line');
    $errors['my_general_error']             = lang('error_line_2');
}
</pre>

<p>Also notice that fields are now in their own array in the object container. This is necessary for Freeform's new abilities for inline errors and better ajax validation.</p>

<h4>Hook Code:</h4>

<pre class="brush: php;">if (ee()-&gt;extensions-&gt;active_hook('freeform_module_validate_end') === TRUE)
{
    $errors = ee()-&gt;extensions-&gt;universal_call(
        'freeform_module_validate_end',
        $errors,
        $this
    );

    if (ee()-&gt;extensions-&gt;end_script === TRUE) return;
}
</pre>

<h4>Extension function example:</h4>

<pre class="brush: php;">public function freeform_module_validate_end($errors, $obj)
{
    //have other extensions already manipulated?
    if (ee()-&gt;extensions-&gt;last_call !== FALSE)
    {
        $errors = ee()-&gt;extensions-&gt;last_call;
    }

    //detect and add custom errors
    $obj-&gt;field_errors['my_field_name'] = lang('error_line');
    $errors['my_general_error']             = lang('error_line_2');

    //must return error array
    return $errors;
}
</pre>

<h4>Detecting Class object:</h4>

<p>Since the hook is called from two different classes, you might need to detect which one for your extension's purposes. This can be achieved two ways:</p>

<p><strong>REQ Detection:</strong></p>

<pre class="brush: php;">if (REQ == 'CP')
{
    //request is from control panel
}
else
{
    //request is from template
}
</pre>

<p><strong>Class Detection:</strong></p>

<pre class="brush: php;">public function freeform_module_validate_end($errors, $obj)
{
    if (get_class($obj) == 'Freeform')
    {
        //request is from template
    }
    else
    {
        //request is from control panel
    }
}
</pre>

<p><a name="freeform_module_insert_begin"></a></p>

<h2>freeform_module_insert_begin</h2>

<p>The freeform_module_insert_begin hook currently exists in both the control panel file and module file, due to create/edit entry abilities in the control panel.</p>

<ul>
<li><strong>Files</strong>:

<ul>
<li>mod.freeform.php</li>
<li>mcp.freeform.php</li>
</ul></li>
<li><strong>Method</strong>:

<ul>
<li>mod.freeform.php -&#62; save_form()</li>
<li>mcp.freeform.php -&#62; save_entry()</li>
</ul></li>
<li><strong>Possible Uses</strong>:

<ul>
<li>Allows developers to alter the field data that will be inputted into the form table for a new entry</li>
</ul></li>
<li><strong>Variables</strong>:

<ul>
<li>$field_input_data:    (array)     - input field from the posted form (only field that are actually in the form, and not the entire $_POST array.)</li>
<li>$entry_id:            (int)       - id of entry (0 if not in edit mode)</li>
<li>$form_id:             (int)       - id of form (always > 0, other wise it's a bug you should report ;D)</li>
<li>$this:                (object)    - class object of function caller</li>
</ul></li>
<li><strong>Important Class Vars</strong>

<ul>
<li>$this->edit:          (bool)  - form is in edit mode</li>
<li>$this->multipage:     (bool)  - form is in multipage mode</li>
<li>$this->last_page:     (bool)  - form is posting the last multipage page</li>
</ul></li>
<li><strong>Return</strong>:

<ul>
<li>type: associative array</li>
<li><strong>required: yes</strong></li>
</ul></li>
</ul>

<p>This hook occurs before fields are inserted and is the ideal time to adjust any values that are going to be inserted into the form's respective entries table.</p>

<h4>Important note about multipage forms and form editing:</h4>

<p>With Freeform Pro, it is possible to have multipage forms and edit forms on the front end.</p>

<p>Hooks fire on every page of the a multipage form as data is stored each time, so if you are wanting to run a hook that only does work on the last page, make sure you are checking for <strong>$obj->multipage == TRUE</strong> and <strong>$obj->last_page == TRUE</strong>.</p>

<p>The same goes for editing. If you do not want your extension to do work on edits, check <strong>$obj->edit == TRUE;</strong> before running your code.</p>

<p>Remember to return required return arrays (and check for <strong>extensions->last_call</strong>) either way!</p>

<h4>Important differences from Freeform 3:</h4>

<p>Freeform 3 only included the first parameter <strong>$data</strong>. As Freeform 4 now has a table per entry and forms are more formal than just a name for a collection, <strong>$form_id</strong> and <strong>$entry_id</strong> are included as well.</p>

<p>For further manipulation, the class object is also included in the hook call.</p>

<h4>Hook Code:</h4>

<pre class="brush: php;">if (ee()-&gt;extensions-&gt;active_hook('freeform_module_insert_begin') === TRUE)
{
    $field_input_data = ee()-&gt;extensions-&gt;universal_call(
        'freeform_module_insert_begin',
        $field_input_data,
        $entry_id,
        $form_id,
        $this
    );

    if (ee()-&gt;extensions-&gt;end_script === TRUE)
    {
        return;
    }
}
</pre>

<h4>Extension function example:</h4>

<pre class="brush: php;">public function freeform_module_insert_begin($inputs, $entry_id, $form_id, $obj)
{
    //have other extensions already manipulated?
    if (ee()-&gt;extensions-&gt;last_call !== FALSE)
    {
        $inputs = ee()-&gt;extensions-&gt;last_call;
    }

    //custom input data
    $inputs['my_field_name']    = 'adjusted value';


    //must return input array
    return $inputs;
}
</pre>

<h4>Detecting Class object:</h4>

<p>Since the hook is called from two different classes, you might need to detect which one for your extension's purposes. This can be achieved two ways:</p>

<p><strong>REQ Detection:</strong></p>

<pre class="brush: php;">if (REQ == 'CP')
{
    //request is from control panel
}
else
{
    //request is from template
}
</pre>

<p><strong>Class Detection:</strong></p>

<pre class="brush: php;">public function freeform_module_insert_begin($inputs, $entry_id, $form_id, $obj)
{
    if (get_class($obj) == 'Freeform')
    {
        //request is from template
    }
    else
    {
        //request is from control panel
    }
}
</pre>

<p><a name="freeform_module_insert_end"></a></p>

<h2>freeform_module_insert_end</h2>

<p>The freeform_module_insert_end hook currently exists in both the control panel file and module file, due to create/edit entry abilities in the control panel.</p>

<ul>
<li><strong>Files</strong>:

<ul>
<li>mod.freeform.php</li>
<li>mcp.freeform.php</li>
</ul></li>
<li><strong>Method</strong>:

<ul>
<li>mod.freeform.php -&#62; save_form()</li>
<li>mcp.freeform.php -&#62; save_entry()</li>
</ul></li>
<li><strong>Possible Uses</strong>:

<ul>
<li>Allows developers to alter the field data that will be inputted into the form table for a new entry</li>
</ul></li>
<li><strong>Variables</strong>:

<ul>
<li>$field_input_data:    (array)     - input field from the posted form (only field that are actually in the form, and not the entire $_POST array.)</li>
<li>$entry_id:            (int)       - id of entry (always > 0 as this is post entry insert)</li>
<li>$form_id:             (int)       - id of form (always > 0, other wise it's a bug you should report ;D)</li>
<li>$this:                (object)    - class object of function caller</li>
</ul></li>
<li><strong>Important Class Vars</strong>

<ul>
<li>$this->edit:          (bool)  - form is in edit mode</li>
<li>$this->multipage:     (bool)  - form is in multipage mode</li>
<li>$this->last_page:     (bool)  - form is posting the last multipage page</li>
</ul></li>
<li><strong>Return</strong>:

<ul>
<li><strong>required: no</strong></li>
</ul></li>
</ul>

<p>This hook occurs after the entry in inserted and is the ideal time to use for integration into other services, or for add-ons that require a reference to the form and entry of a completed form.</p>

<h4>Important note about multipage forms and form editing:</h4>

<p>With Freeform Pro, it is possible to have multipage forms and edit forms on the front end.</p>

<p>Hooks fire on every page of the a multipage form as data is stored each time, so if you are wanting to run a hook that only does work on the last page, make sure you are checking for <strong>$obj->multipage == TRUE</strong> and <strong>$obj->last_page == TRUE</strong>.</p>

<p>The same goes for editing. If you do not want your extension to do work on edits, check <strong>$obj->edit == TRUE;</strong> before running your code.</p>

<h4>Important differences from Freeform 3:</h4>

<p>Freeform 3 only included the first two parameters <strong>$data</strong> and <strong>$entry_id</strong>. Notifications have their own hooks and library now and as such the old <strong>$msg</strong> param that contained notification data has been done away with and replaced with <strong>$form_id</strong>, as Freeform 4 now has a table per entry and forms are more formal than just a name for a collection.</p>

<p>For further manipulation, the class object is also included in the hook call.</p>

<h4>Hook Code:</h4>

<pre class="brush: php;">if (ee()-&gt;extensions-&gt;active_hook('freeform_module_insert_end') === TRUE)
{
    ee()-&gt;extensions-&gt;universal_call(
        'freeform_module_insert_end',
        $field_input_data,
        $entry_id,
        $form_id,
        $this
    );

    if (ee()-&gt;extensions-&gt;end_script === TRUE)
    {
        return;
    }
}
</pre>

<h4>Extension function example:</h4>

<pre class="brush: php;">public function freeform_module_insert_end($inputs, $entry_id, $form_id, $obj)
{
    if ( ! $obj-&gt;edit AND
         ( ! $obj-&gt;multipage OR
            ($obj-&gt;multipage AND $obj-&gt;last_page)
         )
    )
    {
        //do something with final data
    }
}
</pre>

<h4>Detecting Class object:</h4>

<p>Since the hook is called from two different classes, you might need to detect which one for your extension's purposes. This can be achieved two ways:</p>

<p><strong>REQ Detection:</strong></p>

<pre class="brush: php;">if (REQ == 'CP')
{
    //request is from control panel
}
else
{
    //request is from template
}
</pre>

<p><strong>Class Detection:</strong></p>

<pre class="brush: php;">public function freeform_module_insert_end($inputs, $entry_id, $form_id, $obj)
{
    if (get_class($obj) == 'Freeform')
    {
        //request is from template
    }
    else
    {
        //request is from control panel
    }
}
</pre>

<p><a name="freeform_module_form_begin"></a></p>

<h2>freeform_module_form_begin</h2>

<ul>
<li><strong>Files</strong>:

<ul>
<li>mod.freeform.php</li>
</ul></li>
<li><strong>Method</strong>:

<ul>
<li>mod.freeform.php -&#62; form()

<ul>
<li>also via -&#62;edit(), -&#62;composer(), and -&#62;composer_edit(), which call ->form()</li>
</ul></li>
</ul></li>
<li><strong>Possible Uses</strong>:

<ul>
<li>Allows developers to alter <strong>ee()->TMPL->tagdata</strong> before the form is built.</li>
</ul></li>
<li><strong>Variables</strong>:

<ul>
<li>$this:                (object)    - class object of function caller</li>
</ul></li>
<li><strong>Important Class Vars</strong>

<ul>
<li>$this->edit:          (bool)  - form is in edit mode</li>
</ul></li>
<li><strong>Return</strong>:

<ul>
<li><strong>required: no</strong></li>
</ul></li>
</ul>

<p>This hook occurs before the form is built and</p>

<h4>Important note about multipage forms and form editing:</h4>

<p>With Freeform Pro, it is possible to have multipage forms and edit forms on the front end.</p>

<p>At this point in the code, only <strong>$obj->edit</strong> is available, but more parsing must happen before <strong>$obj->multipage == TRUE</strong> and <strong>$obj->last_page</strong> are available.</p>

<h4>Hook Code:</h4>

<pre class="brush: php;">if (ee()-&gt;extensions-&gt;active_hook('freeform_module_form_begin') === TRUE)
{
    ee()-&gt;extensions-&gt;universal_call(
        'freeform_module_form_begin',
        $this
    );

    if (ee()-&gt;extensions-&gt;end_script === TRUE) return;
}
</pre>

<h4>Extension function example:</h4>

<pre class="brush: php;">public function freeform_module_form_begin($obj)
{
    if ( ! $obj-&gt;edit)
    {
        //do something with non-edit forms
    }

    ee()-&gt;TMPL-&gt;tagdata .= 'No one expects the Spanish Inquisition!';
}
</pre>

<p><a name="freeform_module_pre_form_parse"></a></p>

<h2>freeform_module_pre_form_parse</h2>

<ul>
<li><strong>Files</strong>:

<ul>
<li>mod.freeform.php</li>
</ul></li>
<li><strong>Method</strong>:

<ul>
<li>mod.freeform.php -&#62; form()

<ul>
<li>also via -&#62;edit(), -&#62;composer(), and -&#62;composer_edit(), which call ->form()</li>
</ul></li>
</ul></li>
<li><strong>Possible Uses</strong>:

<ul>
<li>Allows developers to alter variables and tagdata before they are sent to the template parser</li>
</ul></li>
<li><strong>Variables</strong>:

<ul>
<li>$tagdata:             (string)    - partially parsed template data</li>
<li>$this:                (object)    - class object of function caller</li>
</ul></li>
<li><strong>Important Class Vars</strong>

<ul>
<li>$this->edit:          (bool)  - form is in edit mode</li>
<li>$this->multipage:     (bool)  - form is in multipage mode</li>
<li>$this->last_page:     (bool)  - form is posting the last multipage page</li>
<li>$this->variables:     (array) - output variables that will be used to parse the tagdata</li>
</ul></li>
<li><strong>Return</strong>:

<ul>
<li>type: string</li>
<li><strong>required: yes</strong></li>
</ul></li>
</ul>

<p>This hook occurs before the form is built and after variables are collected, thus this is a good place to alter any variables before the parser runs.</p>

<h4>Important note about multipage forms and form editing:</h4>

<p>With Freeform Pro, it is possible to have multipage forms and edit forms on the front end.</p>

<p>Hooks fire on every page of the a multipage form as data is stored each time, so if you are wanting to run a hook that only does work on the last page, make sure you are checking for <strong>$obj->multipage == TRUE</strong> and <strong>$obj->last_page == TRUE</strong>.</p>

<p>The same goes for editing. If you do not want your extension to do work on edits, check <strong>$obj->edit == TRUE;</strong> before running your code.</p>

<p>Remember to return required return strings (and check for <strong>extensions->last_call</strong>) either way!</p>

<h4>Hook Code:</h4>

<pre class="brush: php;">if (ee()-&gt;extensions-&gt;active_hook('freeform_module_pre_form_parse') === TRUE)
{
    $tagdata = ee()-&gt;extensions-&gt;universal_call(
        'freeform_module_pre_form_parse',
        $tagdata,
        $this
    );

    if (ee()-&gt;extensions-&gt;end_script === TRUE) return;
}
</pre>

<h4>Extension function example:</h4>

<pre class="brush: php;">public function freeform_module_pre_form_parse($tagdata, $obj)
{

    //have other extensions already manipulated?
    if (ee()-&gt;extensions-&gt;last_call !== FALSE)
    {
        $tagdata = ee()-&gt;extensions-&gt;last_call;
    }

    if ( ! $obj-&gt;edit)
    {
        //do for non-edit forms
    }


    $tagdata .= "Right, enough of that! That's too silly!";

    //required
    return $tagdata;
}
</pre>

<p><a name="freeform_module_form_end"></a></p>

<h2>freeform_module_form_end</h2>

<ul>
<li><strong>Files</strong>:

<ul>
<li>mod.freeform.php</li>
</ul></li>
<li><strong>Method</strong>:

<ul>
<li>mod.freeform.php -&#62; form()

<ul>
<li>also via -&#62;edit(), -&#62;composer(), and -&#62;composer_edit(), which call ->form()</li>
</ul></li>
</ul></li>
<li><strong>Possible Uses</strong>:

<ul>
<li>Allows developers to alter variables and tagdata before they are sent to the template parser</li>
</ul></li>
<li><strong>Variables</strong>:

<ul>
<li>$return:              (string)    - final output tagdata</li>
<li>$this:                (object)    - class object of function caller</li>
</ul></li>
<li><strong>Important Class Vars</strong>

<ul>
<li>$this->edit:          (bool)  - form is in edit mode</li>
<li>$this->multipage:     (bool)  - form is in multipage mode</li>
<li>$this->last_page:     (bool)  - form is posting the last multipage page</li>
<li>$this->variables:     (array) - output variables that will be used to parse the tagdata</li>
</ul></li>
<li><strong>Return</strong>:

<ul>
<li>type: string</li>
<li><strong>required: yes</strong></li>
</ul></li>
</ul>

<p>This hook occurs right at the end of form processing and right before tagdata is returned to the template parser for final output.</p>

<h4>Important note about multipage forms and form editing:</h4>

<p>With Freeform Pro, it is possible to have multipage forms and edit forms on the front end.</p>

<p>Hooks fire on every page of the a multipage form as data is stored each time, so if you are wanting to run a hook that only does work on the last page, make sure you are checking for <strong>$obj->multipage == TRUE</strong> and <strong>$obj->last_page == TRUE</strong>.</p>

<p>The same goes for editing. If you do not want your extension to do work on edits, check <strong>$obj->edit == TRUE;</strong> before running your code.</p>

<p>Remember to return required return strings (and check for <strong>extensions->last_call</strong>) either way!</p>

<h4>Hook Code:</h4>

<pre class="brush: php;">if (ee()-&gt;extensions-&gt;active_hook('freeform_module_form_end') === TRUE)
{
    $return = ee()-&gt;extensions-&gt;universal_call(
        'freeform_module_form_end',
        $return,
        $this
    );

    if (ee()-&gt;extensions-&gt;end_script === TRUE) return;
}
</pre>

<h4>Extension function example:</h4>

<pre class="brush: php;">public function freeform_module_form_end($return, $obj)
{

    //have other extensions already manipulated?
    if (ee()-&gt;extensions-&gt;last_call !== FALSE)
    {
        $return = ee()-&gt;extensions-&gt;last_call;
    }

    if ( ! $obj-&gt;edit)
    {
        //do for non-edit forms
    }


    $return .= 'Listen. Strange women lying in ponds distributing swords is no basis for a system of government!';

    //required
    return $return;
}
</pre>

<p><a name="freeform_module_entry_delete"></a></p>

<h2>freeform_module_entry_delete</h2>

<ul>
<li><strong>Files</strong>:

<ul>
<li>Freeform_forms.php</li>
</ul></li>
<li><strong>Method</strong>:

<ul>
<li>Freeform_forms.php -&#62; delete_entries()

<ul>
<li>called by mcp.freeform.php -&#62; delete_entries()</li>
</ul></li>
</ul></li>
<li><strong>Possible Uses</strong>:

<ul>
<li>Allows developers to adjust other third party code when form entries are deleted.</li>
</ul></li>
<li><strong>Variables</strong>:

<ul>
<li>$form_id              (int)       - form_id of posted entry to notify</li>
<li>$entry_ids            (array)     - entry_id of posted entry to notify</li>
<li>$this:                (object)    - class object of function caller</li>
</ul></li>
<li><strong>Return</strong>:

<ul>
<li><strong>required: no</strong></li>
</ul></li>
</ul>

<p>This hook is called after the verification of entry_ids to be deleted. The entry_ids cannot be affected before deletion and this hook is just for changing data of third party items that relate to form entries.</p>

<h4>Hook Code:</h4>

<pre class="brush: php;">if (ee()-&gt;extensions-&gt;active_hook('freeform_module_entry_delete') === TRUE)
{
    ee()-&gt;extensions-&gt;universal_call(
        'freeform_module_entry_delete',
        $form_id,
        $entry_ids,
        $this
    );

    if (ee()-&gt;extensions-&gt;end_script === TRUE) return;
}
</pre>

<h4>Extension function example:</h4>

<pre class="brush: php;">public function freeform_module_entry_delete($form_id, $entry_ids, $obj)
{
    $this-&gt;my_third_party_table_delete($form_id, $entry_ids);
}
</pre>

<p><a name="freeform_recipient_email"></a>
<a name="freeform_module_admin_notification"></a>
<a name="freeform_module_user_notification"></a></p>

<h2>Notification Hooks</h2>

<ul>
<li>freeform_recipient_email</li>
<li>freeform_module_admin_notification</li>
<li>freeform_module_user_notification</li>
</ul>

<p>These hooks are all run in the same line in the notification library, but are run for different types of notifications. This may seem redundant, but it's for two reasons. Backward compatibility with Freeform 3 hooks and separation of notification types for those who need it. Had the need for Freeform 3 compatibility not arisen, a $type argument could instead have been used.</p>

<p>The odd ordering of hook arguments is also due to backward compatibly and is detailed more later.</p>

<ul>
<li><strong>Files</strong>:

<ul>
<li>Freeform_notifications.php</li>
</ul></li>
<li><strong>Method</strong>:

<ul>
<li>Freeform_notifications.php -&#62; send_notification()

<ul>
<li>called by mod.freeform.php->save_form()</li>
</ul></li>
</ul></li>
<li><strong>Possible Uses</strong>:

<ul>
<li>Allows developers to alter email addresses, subject, message and other varibles before notifications are sent to users.</li>
</ul></li>
<li><strong>Variables</strong>:

<ul>
<li>$this->fields         (array)     - output data of fields by fieldname</li>
<li>$entry_id             (int)       - entry_id of posted entry to notify</li>
<li>$this->variables      (array)     - array of variables that can be adjusted for output</li>
<li>$form_id              (int)       - form_id of posted entry to notify</li>
<li>$this:                (object)    - class object of function caller</li>
</ul></li>
<li><p><strong>Important Class Vars</strong></p>

<ul>
<li>$this->variables['<strong>message</strong>']               - (string) parsed message</li>
<li>$this->variables['<strong>subject</strong>']               - (string) parsed subject</li>
<li>$this->variables['<strong>entry_date</strong>' ]           - (string) Entry Date of posted entry</li>
<li>$this->variables['<strong>attachments</strong>']           - (array) Uploaded files to be attached</li>
<li>$this->variables['<strong>attachment_count</strong>']      - (int) Count of Uploaded files to be attached</li>
<li>$this->variables['<strong>recipients</strong>']            - (array) emails of recipients</li>
<li>$this->variables['<strong>cc_recipients</strong>']         - (array) emails of cc recipients</li>
<li>$this->variables['<strong>bcc_recipients</strong>']        - (array) emails of bcc recipients</li>
<li>$this->variables['<strong>reply_to_email</strong>']        - (string) reply to email address</li>
<li>$this->variables['<strong>reply_to_name</strong>']         - (string) reply to name</li>
<li>$this->variables['<strong>from_name</strong>']             - (string) email sender name</li>
<li>$this->variables['<strong>from_email</strong>']            - (string) email sender email</li>
<li>$this->wordwrap - (boolean) word wrap?</li>
<li>$this->mailtype - (string) 'html' or 'text'</li>
</ul></li>
<li><p><strong>Return</strong>:</p>

<ul>
<li>type: associative array</li>
<li><strong>required: yes</strong></li>
</ul></li>
</ul>

<p>This hook is fired <em>after</em> all parsing of tags is finished, so make any adjustments accordingingly.</p>

<h4>Important differences from Freeform 3:</h4>

<p>Freeform 3 only had hooks for <em>freeform_module_admin_notification</em>, and <em>freeform_module_user_notification</em> and the array was named <strong>$msg</strong> (now <strong>$this->variables</strong>). Freeform 4 uses a table per form, and thus includes the the <strong>$form_id</strong> with hooks.</p>

<p>Freeform 4 also introduces the new <em>freeform_recipient_email</em> hook which covers <a href="form.html#recipients">dynamic</a> and <a href="form.html#recipient_user_input">user input</a> recipients.</p>

<h4>Hook Code:</h4>

<p>The hook code is a little different for notifications as it runs for 3 different kinds.</p>

<pre class="brush: php;">$hook_name = 'freeform_recipient_email';

if ($notification_type == 'admin')
{
    $hook_name = 'freeform_module_admin_notification';
}
else if ($notification_type == 'user')
{
    $hook_name = 'freeform_module_user_notification';
}

if (ee()-&gt;extensions-&gt;active_hook($hook_name) === TRUE)
{
    $this-&gt;variables = ee()-&gt;extensions-&gt;universal_call(
        $hook_name,
        $this-&gt;fields,
        $entry_id,
        $this-&gt;variables,
        $form_id,
        $this
    );

    if (ee()-&gt;extensions-&gt;end_script === TRUE) return;
}
</pre>

<h4>Extension function example:</h4>

<pre class="brush: php;">public function freeform_module_user_notification($fields, $e_id, $vars, $f_id, $obj)
{

    //have other extensions already manipulated?
    if (ee()-&gt;extensions-&gt;last_call !== FALSE)
    {
        $vars = ee()-&gt;extensions-&gt;last_call;
    }

    $nl = ($obj-&gt;mailtype == 'html') ? '&lt;br/&gt;' : "\n";

    $vars['message'] .= $nl . "This form has also been sent to our CRM software! Thanks!";

    //required
    return $vars;
}
</pre>
			</article>
		</div>

		<script src="assets/js/jquery.min.js"></script>
		<script src="assets/fancybox/jquery.fancybox-1.3.4.pack.js"></script>
		<script src="assets/syntaxhighlighter/scripts/shCore.js"></script>
		<script src="assets/syntaxhighlighter/scripts/shAutoloader.js"></script>
		<script src="assets/js/main.js"></script>
	</body>
</html>