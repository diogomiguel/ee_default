<!DOCTYPE html>
<!--[if lt IE 7]>		<html class="no-js ie6"> <![endif]-->
<!--[if IE 7]>			<html class="no-js ie7"> <![endif]-->
<!--[if IE 8]>			<html class="no-js ie8"> <![endif]-->
<!--[if IE 8]>			<html class="no-js ie9"> <![endif]-->
<!--[if gt IE 9]><!-->	<html class="no-js"> <!--<![endif]-->
	<head lang="en">
		<meta charset="utf-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
		<title>Fieldtype Development | Freeform | Solspace Addon Documentation</title>
		<meta name="description" content="" />
		<meta name="copyright" content="(c) 2010 Copyright content: Copyright design: Solspace, Inc."/>
		<meta name="viewport" content="width=device-width" />
		<link rel="stylesheet" href="assets/css/normalize.css" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<link rel="stylesheet" type="text/css" href="assets/fancybox/jquery.fancybox-1.3.4.css" />
		<link href="assets/syntaxhighlighter/styles/shCore.css" rel="stylesheet" type="text/css" />
		<link href="assets/syntaxhighlighter/styles/shThemeDefault.css" rel="stylesheet" type="text/css" />
		<script src="assets/js/modernizr.min.js"></script>
	</head>
	<body>
		<!--[if lt IE 8]>
			<p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
		<![endif]-->

		<header>
			<div class="header-inner">
				<div class="logo">
					<img src="assets/images/logo.png" />
				</div>

				<div class="bread_crumbs">
					<ul class="crumbs">
						<li class="first"><a href="index.html">Freeform</a></li>
						<li>Fieldtype Development</li>
					</ul>
				</div>
			</div>
		</header>

		<div class="content-wrapper">
			<nav class="toc">
				<ul>
<li><a href="http://www.solspace.com/software/detail/freeform/">More Info | Purchase</a></li>
<li><a href="change_log.html">Change Log</a></li>
<li><a href="install_update.html">Install / Update</a></li>
<li><a href="control_panel.html">Control Panel</a></li>
<li><a href="channel_entry_fieldtype.html">Channel Entry Fieldtype</a></li>
<li><a href="default_fieldtypes.html">Default Fieldtypes</a></li>
<li class="current"><a href="fieldtype_development.html">Fieldtype Development</a></li>
<li><a href="extension_hooks.html">Extension Hooks</a></li>
<li><a href="troubleshooting.html">Troubleshooting Guide</a></li>
<li><p><a href="upgrade_3.x-4.x.html">Freeform 3.x to 4.x Guide</a></p></li>
<li class="template_tags"><h3>Template Tags</h3>

<ul>
<li><a href="composer.html">Composer</a></li>
<li><a href="composer_edit.html">Composer_Edit</a></li>
<li><a href="edit.html">Edit</a></li>
<li><a href="entries.html">Entries</a></li>
<li><a href="error_page.html">Error Page</a></li>
<li><a href="form.html">Form</a></li>
<li><a href="form_info.html">Form_Info</a></li>
</ul></li>
<li><h3>Requirements</h3><div class="requirements">

<ul>
<li>ExpressionEngine 2.4+</li>
<li>PHP 5.2+</li>
<li>MySQL 5+</li>
<li>All modern browsers or IE 8+</li>
</ul></div></li>
</ul>
			</nav>

			<article class="docs">
				<p><span class="pro">Pro Only Feature</span></p>

<p>If you wish to develop your own Freeform custom field type, this
documentation should get you started.</p>

<ul>
<li><a href="#basic_file_structure">Basic File Structure</a></li>
<li><a href="#class_variables">Class Variables</a></li>
<li><a href="#function_reference">Function Reference</a></li>
<li><a href="#helper_functions">Helper Functions</a></li>
</ul>

<p><a name="basic_file_structure"></a></p>

<h2>Basic File Structure</h2>

<p>All fieldtypes should be placed into the <em>third_party</em> folder in a
package and be named after that package name. So in a package named
<strong>test_text</strong>, the fieldtype file will be <strong>freeform_ft.test_text.php</strong>. All
fieldtypes must inherit from the <strong>Freeform_base_ft</strong> base class and
they must provide an <strong>$info</strong> array with a name, version number, and
description.</p>

<pre class="brush: php;">&lt;?php if ( ! defined('BASEPATH')) exit('No direct script access allowed');

class Test_text_freeform_ft extends Freeform_base_ft
{
    public  $info   = array(
        'name'          =&gt; 'Test Text',
        'version'       =&gt; '1.0',
        'description'   =&gt; 'Description for Test Text'
    );


    public function display_field ($data)
    {
        return form_input(array(
            'name'  =&gt; $this-&gt;field_name,
            'id'    =&gt; 'freeform_field_' . $this-&gt;field_id,
            'value' =&gt; $data
        ));
    }
}
// END Test_text_freeform_ft class

// End of file freeform_ft.test_text.php
// Location: ./system/expressionengine/third_party/test_text/freeform_ft.test_text.php
</pre>

<p><a name="construction"></a></p>

<h3>Construction</h3>

<p>The parent constructor function sets <strong>$this-&#62;EE</strong> and loads the
Codeigniter form helper. If there is a langauge file available in the
package, it gets autoloaded.</p>

<pre class="brush: php;">public function __construct ()
{
    parent::__construct();

    //pulling from the package lang file to allow translations
    $this-&gt;info['name']         = lang('test_text_name');
    $this-&gt;info['description']  = lang('test_text_desc');
}
//END __construct
</pre>

<p><a name="installation"></a></p>

<h3>Installation</h3>

<p>Each fieldtype can have an install and uninstall function in order to do
extra install routines such as adding database tables.</p>

<pre class="brush: php;">public function install()
{
    //add tables
    //do other stuff
    return;
}
//END install
</pre>

<p><a name="uninstaller"></a></p>

<h3>Uninstaller</h3>

<p>The default <strong>uninstall()</strong> method provided by the <strong>Freeform_ft</strong>
parent class will suffice for fieldtypes that don't install any tables
in their install routine. Most fieldtype methods have sensible defaults
to help reduce duplicate code.</p>

<p><a name="updater"></a></p>

<h3>Updater</h3>

<p>The <strong>update()</strong> method will be run automatically for fields on the
Freeform Fieldtypes control panel page if their database version numbers
and class version numbers do not match.</p>

<p><a name="individual_settings"></a></p>

<h3>Individual Settings</h3>

<p>When a field is created and you select a fieldtype, it can have optional
settings. The <strong>display_settings</strong> function has the current settings
passed in as a parameter (<strong>$data</strong> here). These Individual settings
can be in a table, so they can use <strong>$this-&#62;EE-&#62;table-&#62;add_row()</strong>.
If you wish to use something aside from a table to display settings, you
can return a string and it will be outputted instead of the table. Each
row only has two columns and the common output is a label and a small
description in the first column, then the setting in the next.</p>

<pre class="brush: php;">public function display_settings ($data)
{
    ee()-&gt;table-&gt;add_row(
        lang('field_length', 'field_length') .
            '&lt;div class='subtext'&gt;' .
                lang('field_length_desc') .
            '&lt;/div&gt;',
        form_input(array(
            'name'        =&gt; 'field_length',
            'id'          =&gt; 'field_length',
            'value'       =&gt; isset($data['field_length']) ?
                                $data['field_length'] :
                                $this-&gt;default_length,
            'maxlength'   =&gt; '250',
            'size'        =&gt; '50',
        ))
    );
}
//END display_settings
</pre>

<p><a name="saving_individual_settings"></a></p>

<h3>Saving Individual Settings</h3>

<p>Saving individual field settings requires returning a keyed array of the
settings. These will be the incoming post data from your
<strong>display_settings</strong> function.</p>

<pre class="brush: php;">public function save_settings ()
{
    $fl = ee()-&gt;input-&gt;post('field_length');

    return array(
        'field_length'  =&gt; (is_numeric($fl) ? $fl : 150)
    );
}
//END save_settings
</pre>

<p><a name="display_field_freeform"></a></p>

<h3>Display Field Freeform:Form and Freeform:Edit</h3>

<p>Displaying fields inside the <em>Freeform:Form</em> tag pair can be done with
the <strong>display_field</strong> method. This is output like so:</p>

<pre class="brush: html;">{freeform_field:field_name attar:id='my_field' param='my_param' default_value='stuff'} </pre>

<p>This allows field attributes as well as option params to be passed to
the <strong>display_field</strong> function. The <strong>$data</strong> attribute that is passed
is used when there is incoming data if it is an edit or a multipage
form. The form id and entry ID are set to the class instance as
<strong>$obj-&#62;form_id</strong> and <strong>$obj-&#62;entry_id</strong>. Entry id defaults to 0
if it is not available or its a new entry.</p>

<p>When the <strong>default_value</strong> param set on a field and no edit data or
multipage saved input is available, that default value will be passed to
the fields <strong>$data</strong> variable.</p>

<p><strong>NOTE:</strong> Each instance of the field can have a different default value
passed, so using the <strong>pre_process</strong> function might be affected by the
inclusion of different default values. The <strong>default_value</strong> param will
still be passed to the params array sent to the function so its
detectable if the param was used on the display tag.</p>

<pre class="brush: php;">public function display_field ($data = '', $params = array(), $attr = array())
{
    return form_input(array_merge(array(
        'name'          =&gt; $this-&gt;field_name,
        'id'            =&gt; 'freeform_field_' . $this-&gt;field_id,
        'value'         =&gt; $data,
        'size'          =&gt; '50',
        'maxlength'     =&gt; isset($this-&gt;settings['field_length']) ?
                            $this-&gt;settings['field_length'] :
                            $this-&gt;default_length
    ), $attr));
}
//END display_field
</pre>

<p><a name="display_tag_for_freeform"></a></p>

<h3>Display tag for Freeform:Entries</h3>

<p>The <strong>replace_tag</strong> function is for the <em>Freeform:Entries</em> tag output
and allows you to manipulate data before it is shown to the user. If
there are params on the tag, they are sent in the <strong>$params</strong> array.
Tagpair data is automatically detected and sent to the <strong>$tagdata</strong>
param.</p>

<p>A simple tag will only have a data param. The <strong>$params</strong> param will be
empty and tagdata will be false.</p>

<pre class="brush: html;">{my_field} </pre>

<p>A more advanced tag with params and tagpair data will send those params
in the <strong>$params</strong> argument and the <strong>$tagdata</strong> param will have the
inner data from the tagpair.</p>

<pre class="brush: html;">{my_field one='thing'}
    {if one != 'one'}
        &lt;strong&gt;{one}&lt;/strong&gt;
    {if:else}
        {one}
    {/if}
    {two}
    {three}
{/myfield}
</pre>

<p>The replace function could then look like so.</p>

<pre class="brush: php;">public function replace_tag ($data, $params = array(),
                                $tagdata = FALSE, $query = NULL)
{
    if ($tagdata)
    {
        $my_vars = array(
            'one'   =&gt; isset($params['one']) ? $params['one'] : 'one',
            'two'   =&gt; 'two',
            'three' =&gt; str_replace('ice', 'fire', $data)
        );

        $tagdata = ee()-&gt;TMPL-&gt;parse_variables(array($my_vars), $tagdata);

        return $tagdata;
    }
    else
    {
        return str_replace('ice', 'fire', $data);
    }
}
//END replace_tag
</pre>

<p><a name="pre"></a></p>

<h3>Pre-process tag for Freeform:Entries</h3>

<p>The <strong>pre_process_entries</strong> function comes with a single parameter
that an array of entry ids that has been processed after pagination. If
function, like Freeform:Entries, accepts multiple form IDs, this will be
run for each form ID and its matching entry IDs. This can be used to
make fewer database queries for a field that needs to access its own
table instead of doing it each time a <strong>replace_tag</strong> function is
called. The <strong>pre_process_entries tag</strong> is called one time for each
field until all rows are processed one by one with the <strong>replace_tag</strong>
function.</p>

<p>In this example, we are getting all of the entry ID's from the query
object and caching our data so that each time this field is run, it uses
the cache instead of making a new query. On a page showing 100 items,
this would cut our queries down from 100 to 1 for this field.</p>

<pre class="brush: php;">public function pre_process_entries ($entry_ids = array())
{
    if ( ! empty($entry_ids))
    {
        if ( ! isset($this-&gt;cache['data'][$this-&gt;field_id]))
        {
            $this-&gt;cache['data'][$this-&gt;field_id] = array();

            ee()-&gt;db-&gt;where('form_id', $this-&gt;form_id);
            ee()-&gt;db-&gt;where_in('entry_id', $entry_ids);
            $my_query = ee()-&gt;db-&gt;get('my_table');

            if ($my_query-&gt;num_rows() &gt; 0)
            {
                foreach ($my_query-&gt;result_array() as $row)
                {
                    $this-&gt;cache['data'][$this-&gt;field_id][$this-&gt;form_id][$row['entry_id']] = $row;
                }
            }

            //process leftovers
            foreach ($entry_ids as $entry_id)
            {
                if ( ! isset($this-&gt;cache['data'][$this-&gt;field_id][$this-&gt;form_id][$entry_id]))
                {
                    $this-&gt;cache['data'][$this-&gt;field_id][$this-&gt;form_id][$entry_id] = FALSE;
                }
            }
        }
    }
}
//END pre_process_entries
</pre>

<p><a name="class_variables"></a></p>

<h2>Class Variables</h2>

<p>The base class provides a handful of base variables that are
automatically set:</p>

<ul>
<li><em>$EE</em> - a reference to the controller instance</li>
<li><em>$show_all_sites</em> - is the <strong>Show All Sites</strong> preference set?
(helpful for display)</li>
<li><em>$field_id</em> - the field's database id</li>
<li><em>$field_name</em> - the field short name</li>
<li><em>$form_id</em> - the form ID we are currently working with</li>
<li><em>$entry_id</em> - the entry ID we are currently working with (<strong>0</strong> if
not present)</li>
<li><em>$field_name</em> - the field short name</li>
<li><em>$settings</em> - the field settings array</li>
<li><em>$requires_multipart</em> - set to true if field includes file uploads</li>
<li><em>$edit</em> - data sent to the field is from an edited form</li>
</ul>

<p><a name="function_reference"></a></p>

<h2>Function Reference</h2>

<p>When using the optional class constructor, make sure you call the parent
constructor so that its prep work will still be performed</p>

<pre class="brush: php;">public function __construct()
{
    parent::__construct();
    //your prep work
}
//END __construct()
</pre>

<p><a name="install"></a></p>

<h3>install()</h3>

<p>Installs the fieldtype. Put any installation prep work such as inserting
new tables in this function.</p>

<p><a name="uninstall"></a></p>

<h3>uninstall()</h3>

<p>Handle any cleanup needed to uninstall the fieldtype, including removing
the tables you inserted on install.</p>

<p><a name="update"></a></p>

<h3>update()</h3>

<p>Handle any updates that the fieldtype might run on a new version</p>

<p><a name="remove_from_form"></a></p>

<h3>remove_from_form ($form_id)</h3>

<p>Handle any cleanup needed to remove the fieldtype completely from a
form. The form column is cleaned up automatically. This is run before
the column is deleted.</p>

<p>This will also be run on each field when a form is being entirely
deleted, if the fieldtype is changed, or if the fieldtype is being
deleted. (This is run before delete_field()). Therefore, it is very
important to not delete any data from the form's entry table manually.
This should only be used for cleanup of your secondary data.</p>

<p><a name="delete_field"></a></p>

<h3>delete_field ()</h3>

<p>Handle any cleanup needed when a field has been deleted or changed to
another type other than its current type.</p>

<p><a name="display_field"></a></p>

<h3>display_field($data)</h3>

<p>Used to render the form input field.</p>

<p><em>$data</em> contains the current field data from edit or multipage form
inputs. Blank for new entries.</p>

<p><a name="display_composer_field"></a></p>

<h3>display_composer_field ($data)</h3>

<p>A dummy display output for freeform composer so when a user is building
a form in composer they can have an accurate visual representation of
the field. This defaults to <strong>display_field</strong>'s output, but this can be
used to override or have custom dummy data.</p>

<p><a name="validate"></a></p>

<h3>validate ($data)</h3>

<ul>
<li>Validates the field input.</li>
<li><em>$data</em> contains the submitted field data.</li>
<li>Must return <strong>TRUE</strong>, <strong>FALSE</strong> (generates a generic error message
with the fields label an error message, or an array of error
messages). These messages will be grouped by field when output to
the user either via JSON or the native EE error handler.</li>
</ul>

<p><a name="save"></a></p>

<h3>save ($data)</h3>

<ul>
<li>Preps the data for saving</li>
<li><em>$data</em> contains the submitted field data.</li>
<li>Must return the string to save.</li>
</ul>

<p><a name="post_save"></a></p>

<h3>post_save ($data)</h3>

<ul>
<li>Handles any custom logic after an entry is saved.</li>
<li>Called after an entry is added or updated. Available data is
identical to save, but the settings array includes an <strong>entry_id</strong>
and the class object's <strong>$this-&#62;entry_id</strong> is set to the new
entry's ID. The <strong>settings['entry_id']</strong> is set redundantly to
assist with EE custom field conversion to Freeform fieldtypes.</li>
<li><em>$data</em> contains the submitted field data.</li>
</ul>

<p><a name="delete"></a></p>

<h3>delete ($ids)</h3>

<ul>
<li>Handles any custom logic after an entry is deleted.</li>
<li>Called after one or more entries are deleted.</li>
<li><em>$ids</em> is an array containing the ids of the deleted entries.
Please note that forms data is removed automatically so most
fieldtypes will not need this method. Make sure you check the object
instances <strong>$this-&#62;form_id</strong> variable to delete the correct data.
This will be run before the forms table's data is deleted.</li>
</ul>

<p><a name="replace_tag"></a></p>

<h3>replace_tag($data, $params = array(), $tagdata = FALSE)</h3>

<p>Replace the field tag on the frontend in Freeform:Entries.
<strong>pre_process_entries</strong> runs before these get called:</p>

<ul>
<li><em>$data</em> contains the field data</li>
<li><em>$params</em> contains field parameters (if any)</li>
<li><em>$tagdata</em> contains data between tag (for tag pairs)</li>
</ul>

<p><a name="display_settings"></a></p>

<h3>display_settings($data)</h3>

<p>Display the settings page. The default ExpressionEngine rows can be
created using built in methods. All of these take the current <strong>$data</strong>
and the fieltype name as parameters:</p>

<p><a name="validate_settings"></a></p>

<h3>validate_settings()</h3>

<p>Validates field settings before full save. Return boolean or array of
errors.</p>

<p><a name="save_settings"></a></p>

<h3>save_settings()</h3>

<p>Save the fieldtype settings.</p>

<p>This runs after validation. Check <strong>$this-&#62;EE-&#62;input-&#62;post()</strong> for
the variables</p>

<p><a name="post_save_settings"></a></p>

<h3>post_save_settings($data)</h3>

<p>Do additional processing after the field is created/modified.
<strong>$this-&#62;settings</strong> is fully available at this stage.</p>

<ul>
<li><em>$data</em> contains the submitted settings for this field.</li>
</ul>

<p><a name="pre_process"></a></p>

<h3>pre_process($data)</h3>

<p>Pre-process the data on the frontend. Multiple tag pairs in the same
channel tag will cause <strong>replace_tag</strong> to be called multiple times. To
reduce the processing required to extract the original data structure
from the string (i.e. unserializing), the <strong>pre_process</strong> function is
called first.</p>

<ul>
<li><em>$data</em> contains the field data. Return the prepped data.</li>
</ul>

<p><a name="export"></a></p>

<h3>export($data, $export_type)</h3>

<p>Allows you to affect exported field data before it is sent to be
exported.</p>

<ul>
<li><em>$data</em> is the entry data</li>
<li><em>$export_type</em> is the type of export .e.g xml, json, csv</li>
</ul>

<p><a name="display_entry_cp"></a></p>

<h3>display_entry_cp($data)</h3>

<ul>
<li><em>$data</em> is the entry data</li>
</ul>

<p>Allows you to affect entry field data before it is shown on the CP
entries/moderation pages. <strong>pre_process_entries</strong> <a name="runs_before_these"></a>
runs before these
get called</p>

<p><a name="helper_functions"></a></p>

<h2>Helper Functions</h2>

<p>These are helper functions that are already avaialble inside of the
function</p>

<h3>$this-&#62;yes_no_row($data, $lang, $data_key, $prefix)</h3>

<p>Returns a yes or no set of radio buttons for fields to use in settings.
This adds the rows via <strong>$this-&#62;EE-&#62;table-&#62;add_row()</strong>, so you will
not be able to use this if returning a view instead of using the table
class.</p>

<ul>
<li><em>$data</em> is the input array saved settings</li>
<li><em>$lang</em> is the string of the lang line for the label of the row</li>
<li><em>$data_key</em> is the name attribute that y or n will be outputted
to for the input as well as the data key from the <strong>$data</strong> param
that <strong>yes_no_row</strong> will look for the previous data from.</li>
<li><em>$prefix</em> a prefix for the name attribute in case the name need
be different than the incomming data key (a trailing underscore is
added if not present)</li>
</ul>

<p>To save the data, look for the post value of <strong>$data_key</strong> and
validate it as y or n.</p>

<h3>$this-&#62;text_direction_row($data, $prefix)</h3>

<p>Returns a LTR or RTL set of radio buttons for fields to use in settings.
This adds the rows via <strong>$this-&#62;EE-&#62;table-&#62;add_row()</strong>, so you will
not be able to use this if returning a view instead of using the table
class.</p>

<ul>
<li><em>$data</em> is the input array saved settings</li>
<li><em>$prefix</em> a prefix for the name attribute in case the name need
be different than the incomming data key (a trailing underscore is
added if not present)</li>
</ul>

<p>To save the data, look for your prefix plus _field_text_direction:</p>

<pre class="brush: php;">$text_direction = ee()-&gt;input-&gt;get_post('my_prefix_field_text_direction');
$text_direction = ($text_direction === 'rtl') ? 'rtl' : 'ltr';

return array('my_prefix_field_text_direction' =&gt; $text_direction);
</pre>

<p>Using a prefix is not required, it is just there if you need more than
one text direction row.</p>

<h3>$this-&#62;multi_item_row($data, $prefix, $label, $desc)</h3>

<p>Returns a <strong>LTR</strong> or <strong>RTL</strong> set of radio buttons for fields to use in settings.
This adds the rows via <strong>$this-&#62;EE-&#62;table-&#62;add_row()</strong>, so you will
not be able to use this if returning a view instead of using the table
class.</p>

<ul>
<li><em>$data</em> is the input array saved settings</li>
<li><em>$prefix</em> a prefix for the names attributes in case the names
need be different than the incomming data key (a trailing underscore
is added if not present)</li>
<li><em>$label</em> optional lang key for the label (default
multi_list_items)</li>
<li><em>$desc</em> optional lang key for the description (default
multi_list_items_desc)</li>
</ul>

<p>This will load a view with 4 options for inserting multi-row data:</p>

<ul>
<li>List</li>
<li>Value/Label Pair list</li>
<li>List From Channel Field</li>
<li>Newline Delimited Textarea</li>
</ul>

<p>New blank inputs will create themselves when the last one is used.</p>

<h3>$this-&#62;save_multi_item_row($data, $prefix = FALSE)</h3>

<p>This will return a key value array of the setting name and the list of
items. You must use the same prefix here as you did with
<strong>$this-&#62;multi_item_row</strong>.</p>

<ul>
<li><em>$data</em> is the input array saved settings</li>
<li><em>$prefix</em> a prefix for the names attributes in case the names
need be different than the incomming data key (a trailing underscore
is added if not present)</li>
</ul>

<h3>$this-&#62;multi_item_values($array)</h3>

<p>For use when using <strong>multi_item_row</strong> and <strong>save_multi_item_row</strong>
when wanting to output the chosen data for entries, export. This Takes
an array of keys, a string, or a pipe delimited string of stored values
from the DB and converts them into a key value array from the available
options. If an option is not available, it will return the key again as
the value.</p>

<pre class="brush: php;">$this-&gt;multi_item_values('thing1|thing2');
$this-&gt;multi_item_values('thing1');
$this-&gt;multi_item_values(array('thing1', 'thing2'));
</pre>

<p>and returns the values in a key value array like so:</p>

<pre class="brush: php;">array(
    'thing1' =&gt; 'Thing One',
    'thing2' =&gt; 'Thing Two'
);
</pre>

<h3>$this-&#62;get_field_options($prefix = FALSE, $output = TRUE)</h3>

<p>Gets the stored field options in key/value form if you used
<strong>multi_item_row</strong> and <strong>save_multi_item_row</strong> to store option
settings.</p>

<ul>
<li><em>$prefix</em> prefix for the default stored value name. Must be the
same as the prefix you used to store the data (a trailing underscore
is added if not present)</li>
<li><em>$output</em> if you are using this for front end output, then all of
the values will be put through Codeigniters form_prep form helper
to encode quotes and ascii characters for output.</li>
</ul>

<h3>$this-&#62;load_field_list($use_cache)</h3>

<p>Loads a list of available channels and subfields in an array like so:</p>

<ul>
<li><em>$use_cache</em> caches on first load. Set this to false to load
fresh from database.</li>
</ul>

<pre class="brush: php;">$list['My Channel Title']['1_1'] = 'My Field Label'; </pre>

<p>Where <strong>1_1</strong> is the channel ID, an underscore, and the field ID.</p>

<h3>$this-&#62;is_positive_intlike($num, $threshold)</h3>

<p>Takes a variable and checks to see if it is an integer, and greater than
or equal to the threshold. Returns a boolean. This returns false if a
boolean is passed rather than auto converting the bool to an integer.
This also returns false if the number is a float. This is preferable to
using <strong>ctype_digit</strong> as it accepts strings and integers but does not
case booleans to integers. This is preferable to <strong>is_numeric</strong> as it
accepts floats as well.</p>

<p>The most common use for this is checking a value for a database row key
as they usually autoincrement starting with 1. Hence the default lowest
threshold of 1 and the word positive in the function name.</p>

<ul>
<li><em>$num</em> value to check for intlikeness</li>
<li><em>$threshold</em> minimum value accepted. Defaults to 1.</li>
</ul>

<h3>$this-&#62;get_post_or_zero($name)</h3>

<p>Checks <strong>$this-&#62;EE-&#62;input-&#62;get_post</strong> for a positive integer
greater than 0. If not submitted or the variable is incorrect, returns
0.</p>

<p>This is helpful when you want to whitelist the input from a GET/POST
variable and make sure its positive. This is most commonly used when
expecting values for getting data from a database row.</p>

<ul>
<li><em>$name</em> name of GET/POST variable to check.</li>
</ul>

<h3>$this-&#62;form_table_name($form_id)</h3>

<p>Returns the database name for the <strong>form_id</strong> passed as each form has
its own database and the prefix for the table is changeable in code,
this is the prefered method of retrieving the table name if you need it.</p>

<ul>
<li><em>$form_id</em> ID of the form of which to get the table name for.</li>
</ul>

<h3>$this-&#62;stringify_attributes($array)</h3>

<p>For use with form helper functions that take string attributes instead
of arrays of element attributes.</p>

<p>Takes an array of key values and concats it into a single line for
feeding to the form helper:</p>

<pre class="brush: php;">$attributes = $this-&gt;stringify_attributes(array(
    'id'    =&gt; 'my_id',
    'class' =&gt; 'pretty_button'
));

echo $attributes; //'id='my_id' class='pretty_button''
</pre>
			</article>
		</div>

		<script src="assets/js/jquery.min.js"></script>
		<script src="assets/fancybox/jquery.fancybox-1.3.4.pack.js"></script>
		<script src="assets/syntaxhighlighter/scripts/shCore.js"></script>
		<script src="assets/syntaxhighlighter/scripts/shAutoloader.js"></script>
		<script src="assets/js/main.js"></script>
	</body>
</html>